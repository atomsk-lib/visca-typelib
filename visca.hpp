#pragma once

#include "visca_answer.hpp"
#include "visca_common.hpp"
#include "visca_command.hpp"

/*
	Добавление своих пакетов
	------------------------
	Существует 2 вспомогательных класса которые кодируют значения в пакетах VISCA
		Pack  <N> задаёт байт, который кодируется как 0xNq где q это полезная нагрузка, а N костанта
		Packed<N> задаёт последовательность N байтов, которые кодируются как 0x0q 0x0q 0x0q, где q это число закодированное в Big Endian
	Также существует 2 класса которые задают специфичные поля для пакета VISCA
		Address    кодирует адрес пакета
		Terminator кодирует байт-терминатор пакета
	
	Приведём пример команды ACK, которая кодируется следующим образом
		z0 4y FF, где z это адрес устойства, а y номер командного сокета
	Разбирём этот пример
		z0 это байт адреса                   , для которого у нас есть тип VISCA::Address
		4y это закодированное значение сокета, для которого у нас есть тип VISCA::Pack<4> (первый окет)
		FF это терминатор                    , для которого у нас есть тип VISCA::Terminator
	В итоге мы получаем такую структуру
	struct ACK
	{
		VISCA::Address    address;
		VISCA::Pack<4>    socket;
		VISCA::Terminator terminator;
	};
	
	Приведём пример команды ACK, которая кодируется следующим образом
		8x 01 04 47 0q 0q 0q 0q FF, где х это адресс устройства, а q значение зума в "попугаях"
	Разбирём этот пример
		8x          это байт адреса                 , для которого у нас есть тип VISCA::Address
		01 04 47    это константы                   , для которого задаётся тип const uint8_t[3]
		0q 0q 0q 0q это закодированное значение зума, для которого у нас есть тип VISCA::Packed<4> (4 байта)
		FF          это терминатор                  , для которого у нас есть тип VISCA::Terminator
	В итоге мы получаем такую структуру
	struct Direct
	{
		VISCA::Address    address;
		const uint8_t     command[3] = { 0x01, 0x04, 0x47 };
		VISCA::Packed<4>  data;
		VISCA::Terminator terminator;
	};
	
	!!Будь осторожен с выравниванием, если использовать тип отличный от uchar8_t\char8_t выравнивание может изменить размер пакета!!
	
	
	
	Работа с пакетами
	------------------------
	Для того что бы создать пакет из указателя на память, нужно скопировать эту память в заранее подготовленную переменную
	void example(char* data)
	{
		VISCA::ACK packet;
		memcpy(&packet,data,sizeof(packet));
	}
	Другие способы не считаются безопасными или поддерживаются лишь в новых стандартах (С++23)
	
	Настройка пакета для отправки устроена довольно тривиальна. Покажем на примере VISCA::Zoom::Direct
	auto example()
	{
		VISCA::Zoom::Direct packet{}; //!!фигурные скобки обязательны!!
		packet.address = { 0x01      }       //задаёт только адресс назначение                       , тоесть 0b1000.0xxx
		packet.address = { 0x01, 0x2 }       //задаёт адресс назначение и отправителя                , тоесть 0b1xxx.0yyy
		packet.address = { 0x01, true, 0x2 } //задаёт адресс назначение, отправителя и флаг broadcast, тоесть 0b1xxx.byyy
		//              ^^^ указывать тип необязательно, если использовать фигурные скобки
		packet.data = 0x0004; //задать значение
		int x = packet.data;  //получить значение
		
	
		return packet; //возвращаем сформированный пакет
	}
	
	
	(dev)______________(dev)
	структура типичного пакета
	ZZ QQ RR .. FF
	--------------
	ZZ адресс     -> 0b1SSS.BDDD, S - источник, B - широковещательный, D - назначение
	QQ тип        -> 0x01 команда [RR]
	                 0x09 запрос  [RR]
	                 0x2S отмена  [FF] (ответ на команду это 0x6S с кодом "отмена команды")
	                 0x4S ответ   [FF]   (S-номер сокета)
	                 0x5S успешно [..FF] (S-номер сокета)
	                 0x6S ошибка  [EEFF] (S-номер сокета)
	RR категория  -> 0x00 = интерфейс, 0x04 = камера, 0x06 = панорамирование/наклон
	EE код ошибки -> ###
	FF терминатор -> 0xFF
	(dev)______________(dev)
	Сокет это ID команды которая обрабатывается в данный момент устройством.
	При выполнении команды устройство шлёт результат который содержит ID команды
	(dev)______________(dev)
	Управление сетью (недоступно для IP)
*/